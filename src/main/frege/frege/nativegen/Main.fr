module frege.nativegen.Main where

import frege.Prelude hiding (Class, ClassLoader)
import frege.nativegen.NativeGen
import frege.nativegen.java.Lang
import Data.TreeMap as M()
import Data.List (intercalate)
import Java.Util (List, Iterator)

abstract data KnownTypesParser = KnownTypesParser
  where
    parseLine line
      | (key, _:value) <- break (== '=') line.toList = do
        clsMaybe <- classFor $ packed key
        return $ fmap (\cls -> (cls.getName, parseValue cls (packed value))) clsMaybe
    parseLine _ = return Nothing

    parseKey key = classFor $ packed key

    parseValue cls "" = FregeType (classToFregeName cls) cls.getName Pure
    parseValue cls value = case break (== ',') value.toList of
      (purity, []) -> FregeType (classToFregeName cls) cls.getName (parsePurity $ packed purity)
      (purity, _:fname) -> FregeType (packed fname) cls.getName (parsePurity $ packed purity)

    classToFregeName cls
      | cls.isArray = "JArray " ++ cls.getComponentType.getCanonicalName
      | cls.isPrimitive = packed . applyHead _.toUpperCase . toList $ cls.getName
      | cls.isMemberClass = replace (unqualifiedName cls) "$" "_"
      | otherwise = unqualifiedName cls

    parsePurity "io" = Purity.IO
    parsePurity "st" = Purity.ST
    parsePurity _ = Purity.Pure

    parseKnownTypes fileName = do
      contents <- readFile fileName
      assocMaybes <- mapM parseLine $ lines contents
      return $ M.fromList $ catMaybes assocMaybes

prompt promptStr = do
  print promptStr
  stdout.flush
  getLine

main = do
  knownTypes <- KnownTypesParser.parseKnownTypes "types.properties"
  classLoader <- ClassLoader.current
  packageName <- prompt "Package name: "
  outputDir <- prompt "Output directory: "
  classes <- classesForPackage packageName >>= List.iterator >>= Iterator.toList
  forM_ classes $ convert knownTypes outputDir

convert :: M.Tree String FregeType -> String -> Class a -> IO ()
convert knownTypes outputDir clazz = do
  let nmParts = nameParts clazz
  fileName <- calculateFileName clazz outputDir nmParts
  f <- File.new fileName
  exists <- f.exists
  pw <- createPrintWriter fileName
  let moduleName = intercalate "." nmParts
      moduleDecl = "module " ++ moduleName ++ " where\n"
  when (not exists) (pw.println moduleDecl)
  pw.println $ genFrege knownTypes clazz
  pw.flush
  pw.close

createPrintWriter fileName = do
  f <- File.new fileName
  f.getParentFile >>= (maybe (return false) (File.mkdirs))
  FileWriter.new fileName true >>= BufferedWriter.new >>= PrintWriter.new

calculateFileName :: Class a -> String -> [String] -> IO String
calculateFileName clazz outputDir nameParts = do
  let relativeFileName = intercalate "/" nameParts
  return $ outputDir ++ "/" ++ relativeFileName ++ ".fr"

nameParts :: Class a -> [String]
nameParts clazz = init packageNameParts ++ [fileName] where
  packageNameParts = init . toList $ split clazz.getName "\\."
  fileName = capitalize $ last packageNameParts

data FileWriter = mutable native java.io.FileWriter where
  native new :: String -> Bool -> IO FileWriter throws IOException

data BufferedWriter = mutable native java.io.BufferedWriter where
  native new :: Writer -> IO BufferedWriter

capitalize :: String -> String
capitalize s | (h:t) <- s.toList  = packed $ h.toUpperCase : t
capitalize s = s

pure native toString :: a -> String
pure native split :: String -> String -> JArray String

native classesForPackage frege.nativegen.Main.packageClasses :: String -> STMutable s (List (Class a))

native module where {
  public static java.util.List<Class<?>> packageClasses(String packageName) {
    java.util.List<Class<?>> classes;
    try {
/*
        classes = fj.control.parallel.parMap(
            com.google.common.reflect.ClassPath.from(Thread.currentThread().getContextClassLoader()).getTopLevelClassesRecursive(packageName),
            new fj.F<com.google.common.reflect.ClassPath.ClassInfo, Class<?>>(){
                public Class<?> f(com.google.common.reflect.ClassPath.ClassInfo a) {
                    return a.load();
                }
            }
        )

        classes = fj.data.List.list(
            com.google.common.reflect.ClassPath.from(Thread.currentThread().getContextClassLoader())
            .getTopLevelClassesRecursive(packageName)
        ).map(new fj.F<com.google.common.reflect.ClassPath.ClassInfo, Class<?>>(){
            public Class<?> f(com.google.common.reflect.ClassPath.ClassInfo a) {
                return a.load();
            }
        }).filter(new fj.F<Class<?>, Boolean>(){
            public Boolean f(Class<?> cls) {
                return !cls.isSynthetic() && !cls.isAnonymousClass() && !cls.isLocalClass();
            }
        }).toJavaList();
*/

        classes = com.google.common.reflect.ClassPath.from(Thread.currentThread().getContextClassLoader())
                    .getTopLevelClassesRecursive(packageName)
                    .parallelStream()
                    .map(com.google.common.reflect.ClassPath.ClassInfo::load)
                    .filter(cls -> !cls.isSynthetic() && !cls.isAnonymousClass() && !cls.isLocalClass())
                    .collect(java.util.stream.Collectors.toList());
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    return classes;
  }
}